# 题目

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

# 原题链接

[翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/description/)

# 思路

对于任意一个结点都是交换`左右子树`再返回`头`，所以可以设计一个`递归`函数来实现。


# 设计递归

### 递归含义
1. 对于每一个结点`root`，交换它的左子树和右子树，交换完成后返回二叉树头`root`。
2. 如果`root为空`或`左右子树都为空`就不用交换了。


### 递归过程

#### 对于任意一个结点:

1. 先递进去`左子树`，`左子树`内部交换完毕。
2. 回到`父结点`，递进去`右子树`，`右子树`内部交换完毕。
3. 回到`父结点`，此时`左右子树`内部都已交换好了，交换`左右子树`，返回`父结点`给`爷爷结点`使用。

#### 宏观视角

🔥交换过程是: `左子树`内部交换->`右子树`内部交换->`头`交换`左右子树`，即`左右头`，所以是一个`后序遍历`的过程。

🌲从 `root` 开始，`左子树`一路`递`到底，然后`归`返回到父结点，再`递`进入`右子树`，再`归`返回到`父结点`。然后`父结点`交换`左右子树`，再返回`父结点`给`爷爷结点`使用，这就是宏观的过程。

💡值得注意的是，每次返回的`结点`必然是`以这个结点为头的整棵树`已经交换完毕的了，这一点需要明白。

# 代码

## TypeScript

```typescript
function invertTree(root: TreeNode | null): TreeNode | null {
    // 头为空，不用交换子树，直接返回 root
    if (!root) {
        return root;
    }

    // 左右子树都为空，不用交换子树，直接返回 root
    if (!root.left && !root.right) {
        return root;
    }

    // 1. 来到左子树
    // 左子树`递`进去直到叶子结点，返回叶子头，再到叶子父结点交换左右子树，返回叶子父..
    // 最后返回`整棵左子树交换完毕`的头
    const left = invertTree(root.left);

    // 2. 从左子树回到父结点

    // 3. 从父结点进入右子树
    // 左子树交换完毕，交换右子树
    const right = invertTree(root.right);

    // 4. 从右子树回到父结点
    // 左右子树各自内部的结点交换完毕，头结点的两棵子树开始交换
    root.left = right;
    root.right = left;

    // root这棵树交换完毕，返回头给root的父级使用。
    return root;
};
```